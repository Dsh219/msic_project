# -*- coding: utf-8 -*-
#%%
import numpy as np
import matplotlib.pyplot as plt
# unit in mm, and degree 

Lambda= 0.000729

f=[10,101.38,40]
u=[60]
v=[]
a=[]
s=[0,-122.1]
theta=[0.1]




def y_(d,u,f,theta):
    return (1 - d*(u-f)/(f*u))* u * np.tan(theta * np.pi /180 ) 
    
def a_(f,u,theta):
        
    return f / np.sqrt((f-u)**2 + (Lambda/(np.pi * theta))**2)

def V_(f,u):
    return f * u / (u-f)



def y(d,f,u,v,s,theta,a):
    '''
    

    Parameters
    ----------
    d : float
        seperation between the final lens to the ion.
    f : array/list
        focus lengths of the lens used.
    u : array/list
        seperation between each source to the corresponding len.
    v : array/list
        seperation between each image to the corresponding len.
    s : array/list
        seperation between the consecutive lens.
    theta : array-list 
        divergence angle.
    a : array/list
       magnification constant.

    Returns
    -------
    float
        seperation of the beam at the ion plane.

    '''

    if len(f) < 2 :
        
       f=f[0]
       u=u[0]
       #v=v[0]
       theta=theta[0]
       
       y = y_(d,u,f,theta)  
        
       return y
   
    else:
        
        v0 = V_(f[0],u[0])        
        v.append(v0)
        
        u1 = f[0] + f[1] + s[0] - v[0] 
        u.append(u1)
        
        v1 = V_(f[1],u[1])
        v.append(v1)
        
        a0 = a_(f[0],u[0],theta[0])
        a.append(a0)
        
        theta1 = theta[0] / a[0]
        theta.append(theta1)
        
        a1 = a_(f[1],u[1],theta[1])
        a.append(a1)
        
        
        if len(f) == len(u):
            
            return y_(d,u[-1],f[-1],theta[-1])
        
        else :
            j = 0
            while len(f) > len(u):
                j += 1 
                U = f[j] + f[j+1] + s[j] - v[j]
                #print(U)
                u.append(U)
                V = V_(f[j+1],u[j+1])
                v.append(V)
                Theta = theta[j] / a[j]
                theta.append(Theta)
                A = a_(f[j+1],u[j+1],theta[j+1])
                a.append(A)
                
            return y_(d,u[-1],f[-1],theta[-1])
    
#%%
#quick test
d =30


y = y(d,f,u,v,s,theta,a)


#%%

uu = np.linspace(0,90,31)

yy = []
aa = []

for i in uu :
    u.clear()
    f.clear()
    v.clear()
    a.clear()
    theta.clear()
    
    f=[10,101.38,40]
    u=[]
    v=[]
    a=[]
    s=[0,20]
    theta=[0.1]
    A = 1
    
    u.append(i)
    Y=y(d,f,u,v,s,theta,a) 
    for i in range(len(a)):
        A *= a[i]
    yy.append(Y)
    aa.append(A)
    
    
#%%

data_u = [15,21,27,33,39,45,51,57,66,75,87]
data_y = [0.022682444819,0.047475234891,0.072259983397,0.097031534813,0.12178472594,0.14651438332,0.17121532058,0.19588233591,0.23280783095,0.26962754396,0.31852510094]   

#%%
plt.figure(1)
plt.title('initial sepeartion vs seperation of the beam')
plt.xlabel('u/mm')
plt.ylabel('y/mm')
plt.plot(uu,yy,label='simulation')
plt.plot(data_u,data_y,'x',label='zemax data')
plt.legend()
plt.savefig('u vs y',dpi=300)
#%%

plt.figure(2)
plt.title('initial sepeartion vs magnification')
plt.xlabel('u/mm')
plt.ylabel('a')
plt.plot(uu,aa)
plt.savefig('u vs a',dpi=300)
#%%

    
